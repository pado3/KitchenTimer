// Kitchen timer w/ATmega328P and AQM1248A Graphic LCD. 
//  handmade by @pado3 v1.0 2021/02/17

// font data in EEPROM, use kt_EEPROMw.ino
#include <EEPROM.h>
// hardware SPI, SDO(MOSI)=11,SCK=13
#include <SPI.h>
// use powerdown mode
#include <avr/sleep.h>

#define AINT A0 // read SW with ADC and handle PCINT8
#define Cin A3  // contrast
#define DINT 0  // +1min SW intrruppt number   (D2 = INT0)
#define D2 2    // +1min SW intrruppt pin name (D2 = INT0)
#define LED 5   // LED indicator
#define LVdd 6  // LCD Vdd
#define PGND 7  // SP and LED GND
#define SP  8   // Speaker output
#define RS  9   // Resister Select, H:display data, L:Instruction (aka DI_PIN by synapse-san)
#define CS 10   // /Chip Select (aka CS_PIN by synapse-san)
#define LR 15   // LCD /reset on A1=D14 (ordinary set Hi-Z)
#define CH 16   // LCD contrast reader volume high side on A2=D16
#define CL 18   // LCD contrast reader volume low side on A4=D18
                // otherwise, fixed pins MOSI=D11, SCK=D13, RESET=pin1 are used
// timer global value
byte contrast = 0x1c; // electronic volume value for set contrast, vendor default 0x1c, max 0x3f
byte MM=0, MMpre=0;   // target in minutes, current and previous
byte preset[4] = {12, 7, 5, 3}; // preset target, mugicha, pasta, donbe, ramen
unsigned int thresh[4] = {977, 888, 771, 660}; // common 4.7k, series 0, 470, 1k, 2.2k
unsigned long tcomp = 75;       // time compensation for 1000msec (drawing time and so on)
boolean f_inc = false;          // flag of incrementl MM by DINT to prevent chattering
boolean f_int = false;          // flag of interrupted by AINT
unsigned long t_int = millis(); // previous timing of PCINT8 to prevent chattering

// frame buffer
byte fbuf[6][128];
// start address of font data in EEPROM
int Font[12] = {0, 74, 120, 254, 368, 436, 548, 660, 738, 838, 942, 956};
                      // 0   1    2    3    4    5    6    7    8    9    :
                      // ex."1" for (i=font[1], i< font[2], i++)         ":" [10]-[11]
// x position of each char, 0-9:width28+sp1, ::width10+sp1
byte char_posx[5] = {0, 28, 57, 69, 98};

// runlength encoded font of FINISH generated by kt_rle.py
const byte FINISH[262]= {
            48,2,44,2,50,50,50,50,50,50,50,50,50,50,50,2,9,8,9,20,50,50,50,50,50,50,
            2,9,37,48,2,44,2,50,50,50,50,50,50,50,50,50,50,50,48,2,44,2,50,50,50,50,
            50,50,50,50,3,25,20,6,25,17,9,25,14,12,26,10,16,25,7,19,25,4,21,25,2,2,
            44,2,50,50,50,50,50,50,50,50,48,2,44,2,50,50,50,50,50,50,50,50,50,50,48,
            7,12,11,8,10,5,16,9,12,6,4,18,8,13,5,3,20,7,14,4,3,21,6,15,3,2,23,5,16,
            2,50,1,25,4,16,2,1,26,3,17,1,50,1,27,2,17,1,1,8,7,13,10,8,1,1,7,8,14,10,
            7,1,1,8,8,13,10,7,1,1,15,2,14,7,8,1,1,15,3,28,1,50,1,15,4,27,1,2,14,4,27,
            1,2,14,5,25,2,3,13,6,24,2,3,13,7,23,2,4,12,7,22,3,5,11,9,19,4,7,9,10,17,
            5,29,12,7,48,2,44,2,50,50,50,50,50,50,50,50,50,50,18,10,20,50,50,50,2,44,
            2,50,50,50,50,50,50,50,50,50,50,48,50,
            };

void setup() {
  // serial setup and initial message
  Serial.begin(115200);
  delay(200);
  Serial.println();
  Serial.println(F("START " __FILE__ " from " __DATE__ " " __TIME__));
  // set pinMode and initial value
  pinMode(LED,OUTPUT);      // indicator
  pinMode(PGND,OUTPUT);     // LED and SP GND
  pinMode(LVdd,OUTPUT);     // LCD Vdd
  pinMode(CS,OUTPUT);       // LCD chip select
  pinMode(RS,OUTPUT);       // LCD register select
  pinMode(LR,OUTPUT);       // LCD reset line
  pinMode(CH,OUTPUT);       // Contrast reader volume high side
  pinMode(CL,OUTPUT);       // Contrast reader volume low side
  pinMode(AINT, INPUT);     // minutes set switch read point, analog & digital (interrupt)
  pinMode(D2, INPUT_PULLUP);  // +1 minutes switch interrupt
  pinMode(Cin, INPUT);      // Contrast reader ADC
  digitalWrite(PGND, LOW);  // LED and SP GND
  digitalWrite(CL, LOW);    // contrast volume GND
  digitalWrite(LVdd, HIGH); // LCD Vdd
  digitalWrite(LED,HIGH);   // indicate initialize process started
  // LCD /reset
  digitalWrite(LR, HIGH);   // prepare LCD reset line
  delay(2);                 // omaginai wait
  digitalWrite(LR, LOW);    // LCD hw reset is required after some panic
  delay(3);                 // Reset “L” pulse width /RES tRW 3us, much shorter than this
  digitalWrite(LR, HIGH);   // recover LCD reset line
  pinMode(LR,INPUT);        // set Hi-Z because no use after here and prevent any leak
  // set interrupt +1 min
  attachInterrupt(DINT, incm, LOW);  // pulluped DINT is LOW, invoke incm()
  // SPI setup and initial LCD
  SPI.begin();
  SPI.setClockDivider(SPI_CLOCK_DIV32);
  SPI.setDataMode(SPI_MODE3);
  SPI.setBitOrder(MSBFIRST);
  digitalWrite(CS,HIGH);
  InitializeLcd();
  digitalWrite(LED,LOW);    // LED off when initialize finished
}

void loop() {
  unsigned long pre_t=millis(); // use to check elapsed time, adjust with tcomp (time compensation)
//  Serial.print("DEBUG: start from "); Serial.print(MM = preset[3]); Serial.println("min"); // debug
  byte b[4], i, j=0, f_incsub=0;
  lcd_clear();
  readMM();
  if (0<MM && MM<=99) { // skip counter after RESET (byte has positive only so 0<MM has no meanings)
    for (i=MM; 0<=i && i<=99; i--) {  // minutes, 0-99, byte has positive value only
      do {                            // seconds from zero
        b[0] = (byte) (i/10);           // 1st char for display (10min), cast clearly to prevent bug
        b[1] = (byte) (i - 10*(i/10));  // 2nd (1min)
        b[2] = (byte) (j/10);           // 3rd (10sec)
        b[3] = (byte) (j - 10*(j/10));  // 4th (1sec)
        Serial.print(i); Serial.print(":"); Serial.print(j); Serial.print(" ("); Serial.print(millis() - pre_t); Serial.print("msec)");
        pre_t = millis();
        // Serial.print(" b[0]:"); Serial.print(b[0]);
        // Serial.print(" b[1]:"); Serial.print(b[1]);
        // Serial.print(" b[2]:"); Serial.print(b[2]);
        // Serial.print(" b[3]:"); Serial.print(b[3]);
        make_num(b[0], char_posx[0]); // 10min
        make_num(b[1], char_posx[1]); //  1min
        make_num(10, char_posx[2]);   // ':'
        make_num(b[2], char_posx[3]); // 10sec
        make_num(b[3], char_posx[4]); //  1sec
        digitalWrite(LED,HIGH); // indicator LED
        digitalWrite(CH, HIGH); // contrast volume reader highside
        lcd_draw();
        if(j==0) {
          Serial.print(" po-n");
          lcd_bw(true);
          play_signal();  // 900msec
          delay(500-tcomp);
          digitalWrite(LED,LOW);
          lcd_bw(false);
          delay(500);
        } else if ((i==0 && 0<j && j<=3) || j==30) {
          Serial.print(" pi");
          lcd_bw(true);
          play_pre();     // 187msec
          delay(500-tcomp);
          digitalWrite(LED,LOW);
          lcd_bw(false);
          delay(500);
        } else {
          delay(500-tcomp);
          digitalWrite(LED,LOW);
          delay(500);
        }
        if (f_inc == true) {  // +1min interrupt happened
          if(f_incsub == 0) { // prevent chattering for 3sec
            Serial.print(F(" Increment 1 min with interrupt."));
            lcd_bw(true);
            i++;
          }
          f_incsub++;
          if (3<f_incsub) {
            f_inc=false;  // set flag of increment to false
            f_incsub=0;   // initialize flag sub counter
            lcd_bw(false);
          }
        }
        // set contrast
        contrast = analogRead(Cin)>>4;
        Serial.print(" contrast:"); Serial.print(contrast, HEX);
        if (contrast < 0x0E) contrast = 0x1c;  // maybe disconnect the volume
        lcd_cmd(0x81);      // set electronic volume mode (EVMS) *set before EVRS
        lcd_cmd(contrast);  // set electronic volume resister (EVRS)  *contrast, default 1c
        digitalWrite(CH, LOW);
        if (f_int) {  // interrupt of minutes set is happend
          i=MM;
          j=0;
          f_int = false;
        }
        j--;
        // Serial.print(" AINT:"); Serial.print(analogRead(AINT));
        Serial.println(); // debug: end of second loop
      } while (0<=j && j<59);  // byte has positive value only
      j=59;
    }
    // show FINISH
    make_finish();
    lcd_draw();
    // play finish melody
    Serial.print(" Have a delicious GOHAN!");
    play_melody();
  }
  // powerdown
  Serial.print(" goto powerdown...");
    for (i=0; i<3; i++) {
    digitalWrite(LED, HIGH);
    lcd_bw(true);
    delay(500);
    digitalWrite(LED, LOW);
    lcd_bw(false);
    delay(500);
  }
  powerdown();
}

// read EEPROM and set font data of num(=0-9:) on position x
void make_num(byte num, byte column) {
  boolean line[48], bw; // bw false:white true:black
  byte dat, k;          // read data, line sum
  //unsigned int i=0, j, maxi=Font[num+1]-Font[num];
  int i=0, j, maxi=Font[num+1]-Font[num];
  // Serial.print(F(" num: ")); Serial.print(num); 
  // Serial.print(F(" column: ")), Serial.print(column);
  // Serial.print(F(" data count: "));  Serial.println(maxi);
  do {
    bw=false; k=0;
    if ((dat = EEPROM.read(Font[num]+i)) <= 48) {  // runlength decode a line data
      do {
        for (j=0; j< (dat = EEPROM.read(Font[num]+i)); j++) line[k+j]=bw; // continue same bw
        if (bw == false) bw=true; else bw=false;  // reverse bw
        k += dat; // sum pixel count
        i++;  // inclement font data
      } while (k<48);
    } else {  // if 49<dat, data line is same as previous
      i++; // keep previous line[] and inclement font data
    }
    // make page data of one column
    //for (k=0; k<48; k++) Serial.print(line[k]); // debug, draw font to serial
    //Serial.println(); // debug
    for (k=0; k<6; k++) { 
      fbuf[k][column] = line[k*8+0] + 2*line[k*8+1] + 4*line[k*8+2] + 8*line[k*8+3]
               + 16*line[k*8+4] + 32*line[k*8+5] + 64*line[k*8+6] + 128*line[k*8+7];
    }
    column++;
  } while (i< maxi);
}

// make frame data of FINISH
void make_finish() {
  boolean line[48], bw; // bw false:white true:black
  byte column=0, k;     // column number, line sum
  unsigned int i=0, j, maxi=sizeof(FINISH)/sizeof(byte);
  // Serial.print(F("data count: "));  Serial.println(maxi); // debug
  do {
    bw=false; k=0;
    if (FINISH[i] <= 48) {  // decode line data
      do {
        for (j=0; j<FINISH[i]; j++) line[k+j]=bw; // continue same bw
        if (bw == false) bw=true; else bw=false;  // reverse bw
        k += FINISH[i]; // sum pixel count
        i++;  // inclement font data
      } while (k<48);
    } else {
      i++; // keep previous line[] and inclement font data
    }
    // make page data of one column
    //for (k=0; k<48; k++) Serial.print(line[k]); // debug, draw font to serial
    // Serial.println(); // debug
    for (k=0; k<6; k++) { 
      fbuf[k][column] = line[k*8+0] + 2*line[k*8+1] + 4*line[k*8+2] + 8*line[k*8+3]
               + 16*line[k*8+4] + 32*line[k*8+5] + 64*line[k*8+6] + 128*line[k*8+7];
    }
    column++;
  } while (i< maxi);
}

// play time signal
void play_signal() {
  tone(SP, 880, 900);
}

// play pre bell
void play_pre() {
  tone(SP, 440, 187);
}

// play finish melody
void play_melody() {
  tone(SP, 329, 499); delay(499); noTone(SP); delay(124); // お〜
  tone(SP, 369, 187); delay(187); noTone(SP); delay(46);  // い
  tone(SP, 391, 249); delay(249); noTone(SP); delay(62);  // し
  tone(SP, 369, 150); delay(150); noTone(SP); delay(37);  // い
  tone(SP, 391, 249); delay(249); noTone(SP); delay(62);  // ご
  tone(SP, 329, 150); delay(150); noTone(SP); delay(37);  // は
  tone(SP, 293, 499); delay(499); noTone(SP); delay(124); // ん〜
  tone(SP, 293, 187); delay(187); noTone(SP); delay(46);  //    〜
  tone(SP, 391, 750); delay(750); noTone(SP); delay(187); // だ〜〜
                                                          // 
  tone(SP, 493, 499); delay(499); noTone(SP); delay(124); // さ〜
  tone(SP, 523, 187); delay(187); noTone(SP); delay(46);  // あ
  tone(SP, 493, 375); delay(375); noTone(SP); delay(93);  // た
  tone(SP, 440, 375); delay(375); noTone(SP); delay(93);  // べ
  tone(SP, 391, 750); delay(750); noTone(SP);             // よ〜〜〜
}

// DINT treatment (+1min increment)
void incm() {
  // Serial.println(" DINT happen");
  f_inc=1;  // set increment flag;
}

// AINT treatment (sleep, wakeup)
ISR (PCINT1_vect) { // PCIE1 handler (include PCINT8, why this vector name?)
  // Serial.println(" PCINT8 happen");
  readMM(); // read data and set flag if need
}

void powerdown() {
  Serial.println(" Good night!"); delay(10);
  // LCD sleep with compound command
  lcd_cmd(0xac);    // Static indicator off-1
  lcd_cmd(0x00);    // Static indicator off-2
  lcd_cmd(0xae);    // DISPLAY OFF
  lcd_cmd(0xa5);    // display all points = on
  // AVR sleep
  set_sleep_mode(SLEEP_MODE_PWR_DOWN);
  sleep_enable();   // separate from sleep_mode() for disable BOD (may use 3 clock)
  PCICR  = 0x02;    // enable PCIE1(Pin Change Interrupt Enable 1), include PCINT8
  PCMSK1 = 0x01;    // enable PCINT8 in PCMSK1(Pin Change Mask Register 1)
  ADCSRA = 0x00;    // stop ADC (save 110uA)
  MCUCR |= (1 << BODSE)|(1 << BODS);  // disable BOD with 2 sequential command
  MCUCR = (MCUCR & ~(1 << BODSE))|(1 << BODS);
  // sleep_mode(); // sleep_(enable + cpu + disable), this cannot disable BOD
  sleep_cpu();
  sleep_disable();
}

// read target MM value from SW array
void readMM() {
  unsigned int Ain;
  byte i;
  ADCSRA = 0x80;    // enable ADC
  if (2000 < (millis() - t_int))  { // ignor continuious interrupt in 2 sec
    Serial.print(" readMM with proper interval");
    digitalWrite(LVdd, HIGH); // peripheral power on
    delay(100);               // wait for power up
    InitializeLcd();          // lcd wakeup
    lcd_clear();              // clear LCD noise
    Ain = analogRead(AINT);   // clear noisy charge
    // Serial.print(", readMM:AINT value is "); Serial.print(Ain);
    Ain = analogRead(AINT);
    Serial.print(", readMM:AINT value is "); Serial.print(Ain);
    // byte preset[4] = {12, 7, 5, 3};
    // unsigned int thresh[4] = {977, 888, 771, 660};
    for (i=0; i<sizeof(preset); i++) {
      if (thresh[i] < Ain) {
        break;
      }
    }
    //Serial.print(", found i:"); Serial.print(i);
    if (i < sizeof(preset)) {
      MM = preset[i];
      f_int = true;           // set interrupt flag
    }
    Serial.print(", MM is set to "); Serial.println(MM);
    t_int = millis(); // set previous read timing
  }
}


// LCD common routine recommended by vender (via document of Akizukidenshi-san)
void InitializeLcd() {
  lcd_cmd(0xae);  // DISPLAY OFF
  lcd_cmd(0xa0);  // ADC normal
  lcd_cmd(0xc8);  // COM output scan direction reverse
  lcd_cmd(0xa3);  // bias=1/7 (ST7565)
                  // 3 regulator set ON sequentially
  lcd_cmd(0x2c);  // power control 1
  delay(2);
  lcd_cmd(0x2e);  // power control 2
  delay(2);
  lcd_cmd(0x2f);  // power control 3
                  // CONTRAST settings
  lcd_cmd(0x23);  // set internal resister mode (V0) *don't touch
  lcd_cmd(0x81);  // set electronic volume mode (EVMS) *set before EVRS
  lcd_cmd(contrast);  // set electronic volume resister (EVRS)  *contrast, default 1c
  lcd_cmd(0xa4);  // display all points = normal
  lcd_cmd(0x40);  // set display start line = 0
  lcd_cmd(0xa6);  // set display normal (not reverse)
  lcd_cmd(0xaf);  // DISPLAY ON
}

void lcd_draw() {
  byte page, column;
  for(page=0; page<6; page++) {
    lcd_cmd(0xb0+page);             // set page address
    lcd_cmd(0x10);                  // set upper column address
    lcd_cmd(0x00);                  // set lower column address
    for (column=0; column<127; column++) {
      lcd_dat(fbuf[page][column]);  // write page data
    }
  }
}

void lcd_clear() {  // clear all RAM data to prevent noise
  byte page, column;
  for(page=0; page<6; page++) {
    lcd_cmd(0xb0+page);             // set page address
    lcd_cmd(0x10);                  // set upper column address
    lcd_cmd(0x00);                  // set lower column address
    for (column=0; column<128; column++) {
      fbuf[page][column] = 0;       // clear buffer
      lcd_dat(fbuf[page][column]);  // write page data
    }
  }
}

void lcd_bw(boolean bw) { // bw=true set reverse
  if (bw) lcd_cmd(0xA7); else lcd_cmd(0xA6);
}

// primitive LCD functions
void lcd_cmd(byte cmd) {
  digitalWrite(CS,LOW);
  digitalWrite(RS,LOW);
  SPI.transfer(cmd);
  digitalWrite(CS,HIGH);
} 

void lcd_dat(byte dat) {
  digitalWrite(CS,LOW);
  digitalWrite(RS,HIGH);
  SPI.transfer(dat);
  digitalWrite(CS,HIGH);
}

// end of program
